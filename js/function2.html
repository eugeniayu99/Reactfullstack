<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 명령형 스타일
        let sum = 0;
        for(let i=1; i<=5; i++){
            const squared = i*i;
            sum += squared;
        }
        console.log(sum);
        // 어떻게 할지에 초점이 맞춰져있는 코드이다.
        // 변수 sum을 계속 바꾸면서 결과를 만든다.

        // 함수형 스타일
        const numbers = [1,2,3,4,5];
        const sumOfSquares = numbers
            .map(n => n * n) // 각 숫자를 제곱한 새 배열을 생성
            .reduce((acc,n) => acc + n, 0); // 모두 더하기
        
        console.log(sumOfSquares);
        // 무엇을 할지에 초점이 맞춰져있는 코드이다.
        // numbers배열은 건드리지 않고, 새 값을 만들어서 넘겨준다.

        // 순수함수
        // 같은 입력을 넣으면 항상 같은 출력이 나오는 함수
        // 함수 밖의 상태를 변경하지 않고, 함수 밖의 상태에 의존하지 않는다.

        function add(a,b){
            return a + b;
        }
        // 같은 값을 넣으면 항상 같은 값이 나온다.
        
        let count = 0;
        function increase(){
            count++;
            return count;
        }
        console.log(increase());//1
        console.log(increase());//2
        // 테스트하기가 어렵고, 버그 추적이 힘들다.

        // 실무에서는 비즈니스 로직은 최대한 순수함수로 분리하고 입출력, API호출, DOM조작 같은 부분만 "껍데기"부분에서 처리하는 식으로 설계한다.

        // 불변성
        // 함수형 프로그래밍에서는 원본 데이터를 직접 바꾸지 않고, 복사본이나 새 값을 만들어서 사용하는 것을 선호한다.

        const numbers2 = [1,2,3];
        numbers2.push(4); // 원본배열에 4를 추가
        console.log(numbers2); //[1,2,3,4]

        // 이렇게 해도 동작에는 문제가 없지만, 프로젝트가 커지면 어디서 배열이 바뀐건지 추적하기가 어려워진다.

        const numbers3 = [1,2,3];

        const newNubers = [...numbers3, 4]; // 불변성있게 복사본에 새 값을 추가

        console.log(numbers3);
        console.log(newNubers);

        /******************************************************************/
        const users = [
            {name:'kim', age:20},
            {name:'lee', age:30},
        ];

        // 나이만 +1을 한 새 배열을 만든다.

        const olderUsers = users.map(function(user){
            return {
                ...user,
                age : user.age + 1
            };
        });

        console.log(olderUsers);

        // 배열에서 자주쓰는 함수형 매서드
        // map() : 각 요소를 변환해서 새 배열을 만드는 메서드
        // 예제) 
            const person = [
                {id : 1, name : 'kim'},
                {id : 2, name : 'lee'},
            ];
        /*
            const options = person.map(function(item){
                return {
                    lable : item.name,
                    value : item.id

                }
            });
        */
            const options = person.map(item => ({
                lable : item.name,
                value : item.id
            }));

            console.log(options); // [{label : 'kim', value : 1}, {label : 'lee', value : 2}]
        

        // filter() : 조건을 만족하는 요소만 골라서 새 배열을 만드는 메서드
        // 예제)
            const products = [
                {name:'노트북', price:1500000, soldout : false},
                {name:'마우스', price:20000, soldout : true},
                {name:'키보드', price:150000, soldout : false},
            ]
            // 품절이 아닌 상품만 availableproducts에 넣기
            const availableproducts = products.filter(item => !item.soldout);
            
            console.log(availableproducts);

        // reduce() : 배열을 하나의 값으로 만드는 메서드
        // 예제)
            const carts = [
                {name:'노트북', price:1500000, quantity : 1},
                {name:'마우스', price:20000, quantity : 2},
                {name:'키보드', price:150000, quantity : 3},
            ];
            //카트에 들어있는 모든 상품의 총 합계 구하기
            const cartsTotal = carts.reduce((acc, item) => 
                acc + item.price * item.quantity
            ,0);

            console.log(cartsTotal);
        
            // 숫자를 두배로 만들기
            const double = x => x * 2;
            // 1 을 더하는 함수
            const increment = x => x + 1;
            // 2를 곱하고 1을 더하는 작업을 하고싶다면 두 함수를 합성해서 쓸수 있다.
            const result = increment(double(5));

            // 조금 더 일반적인 함수를 만들 수도 있다.
            // 함수들을 여러 개 받아서 -> 하나의 함수로 합쳐주는 고차 함수
            // ...fns => compose에 넘긴 모든 인자를 배열로 모아서 fns에 넣는다.
            // reduceRighr -> 배열의 오른쪽에서 왼쪽 방향으로 순회하면서 값을 누적시키는 함수
            const compose = (...fns) => x => fns.reduceRight((acc,fn) => fn(acc),x);

            const doubleThenIncrement = compose(increment,double);

            console.log(doubleThenIncrement(5));

    </script>
</body>
</html>